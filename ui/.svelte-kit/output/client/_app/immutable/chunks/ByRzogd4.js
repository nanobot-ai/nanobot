import"./DsnmJJEf.js";import{p as x,d as v,f as S,an as F,a2 as I,g as b,c as $,ao as h,az as L,aA as P,i as c,a8 as l,aB as g,ad as u}from"./DO59wc33.js";import{s as E,r as W}from"./ik-EZS2y.js";import{I as M,S as O,U as D,a as y,W as z}from"./DWFGZehV.js";import{s as A}from"./D7RuEkZb.js";function X(d,e){x(e,!0);/**
 * @license @lucide/svelte v0.540.0 - ISC
 *
 * ISC License
 *
 * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * The MIT License (MIT) (for portions derived from Feather)
 *
 * Copyright (c) 2013-2023 Cole Bemis
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */let t=W(e,["$$slots","$$events","$$legacy"]);const s=[["path",{d:"M12 8V4H8"}],["rect",{width:"16",height:"12",x:"4",y:"8",rx:"2"}],["path",{d:"M2 14h2"}],["path",{d:"M20 14h2"}],["path",{d:"M15 13v2"}],["path",{d:"M9 13v2"}]];M(d,E({name:"bot"},()=>t,{get iconNode(){return s},children:(i,a)=>{var o=v(),r=S(o);F(r,()=>e.children??I),b(i,o)},$$slots:{default:!0}})),$()}function Z(d,e){x(e,!0);/**
 * @license @lucide/svelte v0.540.0 - ISC
 *
 * ISC License
 *
 * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * The MIT License (MIT) (for portions derived from Feather)
 *
 * Copyright (c) 2013-2023 Cole Bemis
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */let t=W(e,["$$slots","$$events","$$legacy"]);const s=[["rect",{x:"3",y:"5",width:"6",height:"6",rx:"1"}],["path",{d:"m3 17 2 2 4-4"}],["path",{d:"M13 6h8"}],["path",{d:"M13 12h8"}],["path",{d:"M13 18h8"}]];M(d,E({name:"list-todo"},()=>t,{get iconNode(){return s},children:(i,a)=>{var o=v(),r=S(o);F(r,()=>e.children??I),b(i,o)},$$slots:{default:!0}})),$()}function ee(d,e){x(e,!0);/**
 * @license @lucide/svelte v0.540.0 - ISC
 *
 * ISC License
 *
 * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * The MIT License (MIT) (for portions derived from Feather)
 *
 * Copyright (c) 2013-2023 Cole Bemis
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */let t=W(e,["$$slots","$$events","$$legacy"]);const s=[["path",{d:"M5 12h14"}],["path",{d:"M12 5v14"}]];M(d,E({name:"plus"},()=>t,{get iconNode(){return s},children:(i,a)=>{var o=v(),r=S(o);F(r,()=>e.children??I),b(i,o)},$$slots:{default:!0}})),$()}const j=()=>{const d=A;return{page:{subscribe:d.page.subscribe},navigating:{subscribe:d.navigating.subscribe},updated:d.updated}},te={subscribe(d){return j().page.subscribe(d)}};var J=["forEach","isDisjointFrom","isSubsetOf","isSupersetOf"],U=["difference","intersection","symmetricDifference","union"],_=!1;class k extends Set{#s=new Map;#e=h(0);#t=h(0);#a=P||-1;constructor(e){if(super(),e){for(var t of e)super.add(t);this.#t.v=super.size}_||this.#o()}#i(e){return P===this.#a?h(e):L(e)}#o(){_=!0;var e=k.prototype,t=Set.prototype;for(const s of J)e[s]=function(...i){return c(this.#e),t[s].apply(this,i)};for(const s of U)e[s]=function(...i){c(this.#e);var a=t[s].apply(this,i);return new k(a)}}has(e){var t=super.has(e),s=this.#s,i=s.get(e);if(i===void 0){if(!t)return c(this.#e),!1;i=this.#i(!0),s.set(e,i)}return c(i),t}add(e){return super.has(e)||(super.add(e),l(this.#t,super.size),g(this.#e)),this}delete(e){var t=super.delete(e),s=this.#s,i=s.get(e);return i!==void 0&&(s.delete(e),l(i,!1)),t&&(l(this.#t,super.size),g(this.#e)),t}clear(){if(super.size!==0){super.clear();var e=this.#s;for(var t of e.values())l(t,!1);e.clear(),l(this.#t,0),g(this.#e)}}keys(){return this.values()}values(){return c(this.#e),super.values()}entries(){return c(this.#e),super.entries()}[Symbol.iterator](){return this.keys()}get size(){return c(this.#t)}}const N="application/vnd.nanobot.task+json",T="application/vnd.nanobot.agent+json",C="application/vnd.nanobot.conversation+json",Y="application/vnd.nanobot.flowchart+json";class B{workspaceId;#s=h(u([]));get items(){return c(this.#s)}set items(e){l(this.#s,e,!0)}#e=h(u([]));get files(){return c(this.#e)}set files(e){l(this.#e,e,!0)}#t=h(u([]));get taskFlowcharts(){return c(this.#t)}set taskFlowcharts(e){l(this.#t,e,!0)}#a=h(u(new k));get expandedSections(){return c(this.#a)}set expandedSections(e){l(this.#a,e,!0)}#i=h(u(new k));get expandedFilePaths(){return c(this.#i)}set expandedFilePaths(e){l(this.#i,e,!0)}#o=h(!1);get isLoading(){return c(this.#o)}set isLoading(e){l(this.#o,e,!0)}client;unwatchResources;constructor(e){this.workspaceId=e,this.client=new O({path:`${D}&workspace=${e}`}),this.loadExpandedState()}classifyResource(e){if(!e.uri.startsWith("workspace://"))return null;const t=e.annotations?.lastModified||new y().toISOString();switch(e.mimeType){case N:return{type:"item",data:{id:e.uri.replace("workspace://tasks/",""),workspaceId:this.workspaceId,type:"task",title:e.name||"Untitled Task",created:t,status:"active"}};case T:return{type:"item",data:{id:e.uri.replace("workspace://agents/",""),workspaceId:this.workspaceId,type:"agent",title:e.name||"Untitled Agent",created:t,status:"active"}};case C:return{type:"item",data:{id:e.uri.replace("workspace://conversations/",""),workspaceId:this.workspaceId,type:"conversation",title:e.name||"Untitled Conversation",created:t,status:"active"}};case Y:return null;default:if(e.uri.startsWith("workspace://files/")){const s=e.uri.replace("workspace://files/","");return{type:"file",data:{id:s,workspaceId:this.workspaceId,path:s,created:t,size:e.size||0,mimeType:e.mimeType}}}return null}}async updateSingleResource(e){const t=e.uri,s=!t.startsWith("workspace://");let i;if(s){const r=(await this.client.listResources({prefix:t})).resources?.find(n=>n.uri===t);if(!r)return;i=r}else{const o=new y().toISOString();i={uri:e.uri,mimeType:e.mimeType,name:"",annotations:{lastModified:o}}}const a=this.classifyResource(i);if(a){if(a.type==="item"){const o=this.items.findIndex(r=>r.id===a.data.id);o>=0?((!a.data.title||a.data.title==="Untitled Task"||a.data.title==="Untitled Agent"||a.data.title==="Untitled Conversation")&&(a.data.title=this.items[o].title),this.items[o]=a.data,this.items=[...this.items]):this.items=[...this.items,a.data]}else if(a.type==="file"){const o=this.files.findIndex(r=>r.id===a.data.id);o>=0?(this.files[o]=a.data,this.files=[...this.files]):this.files=[...this.files,a.data]}}}async load(){this.isLoading=!0;try{const e=await this.client.listResources({prefix:"workspace://"});if(!e.resources||e.resources.length===0)this.items=[],this.files=[],this.taskFlowcharts=[];else{const t=[],s=[];for(const i of e.resources){const a=this.classifyResource(i);a&&(a.type==="item"?t.push(a.data):a.type==="file"&&s.push(a.data))}this.items=t,this.files=s,this.taskFlowcharts=[]}this.unwatchResources=this.client.watchResource("workspace://",t=>{this.updateSingleResource(t)})}catch(e){console.error("Failed to load workspace items:",e),this.items=[],this.files=[],this.taskFlowcharts=[]}finally{this.isLoading=!1}}getTaskFlowchart(e){return this.taskFlowcharts.find(t=>t.taskId===e)}async toggleNodeCompletion(e,t){const s=this.taskFlowcharts.find(i=>i.taskId===e);if(s){const i=s.nodes.find(a=>a.id===t);i&&i.type!=="start"&&i.type!=="end"&&(i.completed=!i.completed,await this.updateFlowchart(e,s))}}async updateFlowchart(e,t){await this.client.callMCPTool("update_resource",{payload:{uri:`workspace://flowcharts/${e}`,text:JSON.stringify(t)}}),this.taskFlowcharts=[...this.taskFlowcharts]}async removeNodeAssignment(e,t,s,i){const a=this.taskFlowcharts.find(o=>o.taskId===e);if(a){const o=a.nodes.find(r=>r.id===t);if(o&&o[s]){const r=o[s],n=r.indexOf(i);n>-1&&(r.splice(n,1),await this.updateFlowchart(e,a))}}}async addNodeAssignment(e,t,s,i){const a=this.taskFlowcharts.find(o=>o.taskId===e);if(a){const o=a.nodes.find(r=>r.id===t);o&&(o[s]||(o[s]=[]),o[s].includes(i)||(o[s].push(i),await this.updateFlowchart(e,a)))}}async addEdge(e,t,s,i){const a=this.taskFlowcharts.find(o=>o.taskId===e);if(a){const o={id:`e${Date.now()}`,source:t,target:s,label:i};a.edges.push(o),await this.updateFlowchart(e,a)}}async createNode(e,t,s,i,a){const o=this.taskFlowcharts.find(r=>r.taskId===e);if(o){const r=`node-${Date.now()}`;let n={x:250,y:100};if(a){const w=o.nodes.find(p=>p.id===a);w&&(n={x:w.position.x,y:w.position.y+150})}else n={x:250,y:Math.max(...o.nodes.map(p=>p.position.y))+150};const f={id:r,type:t,label:s,content:i,position:n};return o.nodes.push(f),await this.updateFlowchart(e,o),r}throw new Error("Task flowchart not found")}async updateEdge(e,t,s){const i=this.taskFlowcharts.find(a=>a.taskId===e);if(i){const a=i.edges.find(o=>o.id===t);a&&(Object.assign(a,s),await this.updateFlowchart(e,i))}}async deleteEdge(e,t){const s=this.taskFlowcharts.find(i=>i.taskId===e);s&&(s.edges=s.edges.filter(i=>i.id!==t),await this.updateFlowchart(e,s))}async addNodeInput(e,t,s,i,a){const o=this.taskFlowcharts.find(r=>r.taskId===e);if(o){const r=o.nodes.find(n=>n.id===t);if(r){r.inputs||(r.inputs=[]);const n={id:`input-${Date.now()}`,name:s,description:i,required:a};r.inputs.push(n),await this.updateFlowchart(e,o)}}}async updateNodeInput(e,t,s,i){const a=this.taskFlowcharts.find(o=>o.taskId===e);if(a){const o=a.nodes.find(r=>r.id===t);if(o&&o.inputs){const r=o.inputs.find(n=>n.id===s);r&&(Object.assign(r,i),await this.updateFlowchart(e,a))}}}async deleteNodeInput(e,t,s){const i=this.taskFlowcharts.find(a=>a.taskId===e);if(i){const a=i.nodes.find(o=>o.id===t);a&&a.inputs&&(a.inputs=a.inputs.filter(o=>o.id!==s),await this.updateFlowchart(e,i))}}getItems(e){return this.items.filter(t=>!e||t.type===e)}getItemCount(e){return this.items.filter(t=>t.type===e).length}getFiles(){return this.files}getFileCount(){return this.files.length}buildFileTree(){const e=this.getFiles(),t=[];for(const i of e){const a=i.path.split("/");let o=t;for(let r=0;r<a.length;r++){const n=a[r],f=r===a.length-1,w=a.slice(0,r+1).join("/");let p=o.find(m=>m.name===n);if(!p){const m={name:n,path:w,isDirectory:!f,file:f?i:void 0};f||(m.children=[]),o.push(m),p=m}!f&&p.children&&(o=p.children)}}const s=i=>{i.sort((a,o)=>a.isDirectory&&!o.isDirectory?-1:!a.isDirectory&&o.isDirectory?1:a.name.localeCompare(o.name)),i.forEach(a=>{a.children&&s(a.children)})};return s(t),t}toggleFilePath(e){this.expandedFilePaths.has(e)?this.expandedFilePaths.delete(e):this.expandedFilePaths.add(e),this.saveExpandedState()}isFilePathExpanded(e){return this.expandedFilePaths.has(e)}toggleSection(e){this.expandedSections.has(e)?this.expandedSections.delete(e):this.expandedSections.add(e),this.saveExpandedState()}isSectionExpanded(e){return this.expandedSections.has(e)}async createItem(e,t){const s=`${e}-${Date.now()}`;let i,a;switch(e){case"task":i=N,a=`workspace://tasks/${s}`;break;case"agent":i=T,a=`workspace://agents/${s}`;break;case"conversation":i=C,a=`workspace://conversations/${s}`;break}await this.client.callMCPTool("create_resource",{payload:{uri:a,name:t,mimeType:i}});const o=new y().toISOString(),r={id:s,workspaceId:this.workspaceId,type:e,title:t,created:o,status:"active"};return this.items=[...this.items,r],r}async updateItem(e,t){const s=this.items.findIndex(r=>r.id===e);if(s===-1)throw new Error("Item not found");const i=this.items[s];let a;switch(i.type){case"task":a=`workspace://tasks/${e}`;break;case"agent":a=`workspace://agents/${e}`;break;case"conversation":a=`workspace://conversations/${e}`;break}await this.client.callMCPTool("update_resource",{payload:{uri:a,...t.title&&{name:t.title}}});const o={...i,...t};return this.items=[...this.items.slice(0,s),o,...this.items.slice(s+1)],o}async deleteItem(e){const t=this.items.find(i=>i.id===e);if(!t)throw new Error("Item not found");let s;switch(t.type){case"task":s=`workspace://tasks/${e}`;break;case"agent":s=`workspace://agents/${e}`;break;case"conversation":s=`workspace://conversations/${e}`;break}await this.client.callMCPTool("delete_resource",{payload:{uri:s}}),this.items=this.items.filter(i=>i.id!==e)}close(){this.unwatchResources&&(this.unwatchResources(),this.unwatchResources=void 0),this.saveExpandedState(),this.items=[],this.files=[],this.taskFlowcharts=[],this.expandedSections.clear(),this.expandedFilePaths.clear(),this.isLoading=!1}loadExpandedState(){try{const e=localStorage.getItem(`nanobot-expanded-sections-${this.workspaceId}`);e&&JSON.parse(e).forEach(i=>this.expandedSections.add(i));const t=localStorage.getItem(`nanobot-expanded-file-paths-${this.workspaceId}`);t&&JSON.parse(t).forEach(i=>this.expandedFilePaths.add(i))}catch(e){console.error("Failed to load expanded state:",e)}}saveExpandedState(){try{localStorage.setItem(`nanobot-expanded-sections-${this.workspaceId}`,JSON.stringify([...this.expandedSections])),localStorage.setItem(`nanobot-expanded-file-paths-${this.workspaceId}`,JSON.stringify([...this.expandedFilePaths]))}catch(e){console.error("Failed to save expanded state:",e)}}}class R{client;constructor(e){this.client=e?.client||new O}async listWorkspaces(){const e=await this.client.listResources({prefix:"nanobot://workspaces/"});if(!e.resources)return[];const t=[];for(const s of e.resources)if(s.uri?.startsWith("nanobot://workspaces/")&&s.mimeType===z)try{const a={id:s.uri.split("/").pop()||"",name:s.name,created:s.annotations?.lastModified||"",icons:s.icons},o=s._meta?.["ai.nanobot"];o&&(typeof o.order=="number"&&(a.order=o.order),typeof o.color=="string"&&(a.color=o.color)),t.push(a)}catch(i){console.error("Failed to parse workspace resource:",i)}return t}async createWorkspace(e){return await this.client.callMCPTool("create_workspace",{payload:e})}async updateWorkspace(e,t){return await this.client.callMCPTool("update_workspace",{payload:{uri:`nanobot://workspaces/${e}`,...t}})}async deleteWorkspace(e){await this.client.callMCPTool("delete_workspace",{payload:{uri:`nanobot://workspaces/${e}`}})}}new R;class H{#s=h(u([]));get workspaces(){return c(this.#s)}set workspaces(e){l(this.#s,e,!0)}#e=h(u(new k));get expandedWorkspaceIds(){return c(this.#e)}set expandedWorkspaceIds(e){l(this.#e,e,!0)}#t=h(!1);get isLoading(){return c(this.#t)}set isLoading(e){l(this.#t,e,!0)}itemStoreCache=new Map;service;constructor(e){this.service=e?.service||new R,this.loadExpandedState()}getItemStore(e){let t=this.itemStoreCache.get(e);return t||(t=new B(e),this.itemStoreCache.set(e,t)),t}clearItemStore(e){const t=this.itemStoreCache.get(e);t&&(t.close(),this.itemStoreCache.delete(e))}async load(){this.isLoading=!0;try{this.workspaces=await this.service.listWorkspaces()}catch(e){console.error("Failed to load workspaces:",e),this.workspaces=[]}finally{this.isLoading=!1}}toggleWorkspace(e){this.expandedWorkspaceIds.has(e)?this.expandedWorkspaceIds.delete(e):this.expandedWorkspaceIds.add(e),this.saveExpandedState()}isWorkspaceExpanded(e){return this.expandedWorkspaceIds.has(e)}async createWorkspace(e){const t=await this.service.createWorkspace({name:e,order:this.workspaces.length});return this.workspaces=[...this.workspaces,t],t}async updateWorkspace(e,t){const s=this.workspaces.findIndex(n=>n.id===e);if(s===-1)throw new Error("Workspace not found");const{id:i,created:a,...o}=t,r=await this.service.updateWorkspace(e,o);return this.workspaces=[...this.workspaces.slice(0,s),r,...this.workspaces.slice(s+1)],r}async deleteWorkspace(e){await this.service.deleteWorkspace(e),this.workspaces=this.workspaces.filter(t=>t.id!==e),this.clearItemStore(e),this.expandedWorkspaceIds.delete(e),this.saveExpandedState()}loadExpandedState(){try{const e=localStorage.getItem("nanobot-expanded-workspaces");e&&JSON.parse(e).forEach(s=>this.expandedWorkspaceIds.add(s))}catch(e){console.error("Failed to load expanded state:",e)}}saveExpandedState(){try{localStorage.setItem("nanobot-expanded-workspaces",JSON.stringify([...this.expandedWorkspaceIds]))}catch(e){console.error("Failed to save expanded state:",e)}}}const se=new H;export{X as B,Z as L,ee as P,te as p,se as w};
